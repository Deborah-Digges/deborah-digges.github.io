{"componentChunkName":"component---src-templates-blog-template-js","path":"/2015/01/10/Stroustrup-on-Campus/","result":{"data":{"markdownRemark":{"html":"<p>It’s not everyday that the creator of C++ visits your campus. And when he does, everyone scurries around in giddy excitement hoping to exchange a word with him at least. Today was that day for PES University. At 11AM, Bjarne Stroustrup entered the auditorium, sending a wave of hushes down the rows of students and teachers, as the crowd fell silent and stood to applaud him. </p>\n<h2>The  Essence of C++</h2>\n<p>“Lots of people have really different ideas about what C++ is\", Stroustrup began, using the analogy of a blind man trying to describe an elephant: “a tail, a trunk, perhaps a wonderfully large leg, is as far as he would get”. The ultimate aim of a  programming language is to build <em>maintainable systems</em> and often in the deluge of details and nuances we lose sight of the bigger picture. </p>\n<h3>What is C++?</h3>\n<p>C++, he explained, is a systems programming language, used in embedded systems and other resource constrained environments. </p>\n<blockquote>\n<p>“C++ is expert friendly, but it is not <em>just</em> expert friendly.”</p>\n</blockquote>\n<h2>Resource Management</h2>\n<p>He went on to explain the concept of a resource as anything that needs to be released after having been initially acquired. </p>\n<blockquote>\n<p>“It’s not just memory; There’s file handles, locks, sockets, threads. If you leak enough file handles, your OS would freeze!”</p>\n</blockquote>\n<h2>Pointer Misuse</h2>\n<blockquote>\n<p>“The complexity of your code should reflect the complexity of what you’re doing”</p>\n</blockquote>\n<pre><code class=\"language-c++\">void f(int x, int n)\n{\n    Gadget * g = new Gadget{n}; // Look ! I’m a Java Programmer :)\n    if(x &#x3C; 100) throw std::runtime_error{\"weird\"}; //leak\n    if(x &#x3C; 200) return; //leak\n    delete p;\n}\n</code></pre>\n<p>Stroustrup went through the problems with raw pointers explaining how leaks occur when a pointer is not freed in the case of an exception or a return.</p>\n<blockquote>\n<p>“Most uses of pointers in local scope are not exception safe”.</p>\n</blockquote>\n<p>The cleaner approach, he explained, would be to use a unique_ptr,which fires the destructor for the object as soon as the unique_ptr is destroyed.</p>\n<pre><code class=\"language-c++\">unique_ptr&#x3C;Gadget> g {new Gadget{n}}; // Manage that pointer!\n</code></pre>\n<p>“Why use a pointer at all? Just use a scoped variable”</p>\n<pre><code class=\"language-c++\">Gadget g{n}; // Death to the pointer!\n</code></pre>\n<h2>How do you get a large amount of data out of a function?</h2>\n<pre><code class=\"language-c++\">?? operator+(const Matrix&#x26; a, const Matrix&#x26; b)\n{\n}\n</code></pre>\n<p>The ways in which data can be passed out of functions were explained:</p>\n<ol>\n<li>POINTER to a new’d object - Who owns the object and who would be responsible for it’s destruction? This adds to code complexity and often causes leaks.</li>\n<li>REFERENCE to a new’d object - Who does the delete? <em>What delete</em>. We have made the notation pleasant at the cost of hiding the problem.</li>\n<li>OBJECT - object copies are <em>expensive</em>.</li>\n<li>SMART POINTER - still need to dereference it.</li>\n</ol>\n<h2>Move Semantics</h2>\n<p>He went on to explain C++11’s solution to the problem:</p>\n<pre><code class=\"language-c++\">Matrix operator+(const Matrix&#x26; a, const Matrix&#x26; b)\n{\n    Matrix result;\n    // copy a[i] + b[i] into result[i] for each i\n    return result;\n}\n</code></pre>\n<pre><code class=\"language-c++\">Matrix c = a + b;\n</code></pre>\n<p>“Don’t copy, <em>steal</em> the representation”</p>\n<pre><code class=\"language-c++\">class Matrix\n{\n    Representation rep;\n    Matrix(Matrix&#x26;&#x26; a) //Move Constructor\n    {\n        rep = a.rep; //*this gets a’s elements\n        a.rep = {} //a becomes the empty matrix\n    }\n};\n</code></pre>\n<p>The local object <em>result</em> created in the function is returned by <em>value</em> and a special <em>move constructor</em> is used in the creation of the object c, by the caller. This move constructor <em>steals</em> the representation of the local object <em>result</em>. It makes the newly created object <em>c</em> point to this object, while making the local object <em>result</em> the empty object.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 443px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/f7278ec3786e0099f28691b469604df8/a120c/move_ctor.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 64.99999999999999%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAAAsTAAALEwEAmpwYAAABbklEQVQ4y4VT246CMBTk///DX/AFY2IiT5qoRGLEqC8qxhsgigra2U43kNIF9yRNy+lhOjOntfBPCCG+5s19q0gWo66Y83w+x2w2w36/rwUt1pZ5gv6t/7BYLOB5HrbbLS6XS6VGrysZ5nlee6I+3243teZ8PB6RZRlMhQowDENsNhs8Ho9GKdnrhUhjJgkIgiZJwoJyKECZRBAEOBwOjabn1ysS15XIWcWh3W6H9XqtMK6yppT8fr9xv9+VFK5NhrkEiiVDbzpFp9OBO5mIbrcL13XF6XQSsllkLFRTPp9PeSR9IdM0TasMpcdhFCGQXXb6fTiOIwaDAQjGoAUS51eyDlaELEQcx5U9SjJq/1xSi+x830ev10O73cZoNEIkmTAISGAG69g884oJIxTD5XKJ4XCogMfjsTK4CEpnnuZPpX/cez6fja/F+vbkCm/P5zNs20ar1cJqtSoPrHuWln4pm54gWRKU8inbZKjHDyLJ8dOSJ4FIAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"MOVE_CTOR\"\n        title=\"MOVE_CTOR\"\n        src=\"/static/f7278ec3786e0099f28691b469604df8/a120c/move_ctor.png\"\n        srcset=\"/static/f7278ec3786e0099f28691b469604df8/772e8/move_ctor.png 200w,\n/static/f7278ec3786e0099f28691b469604df8/e17e5/move_ctor.png 400w,\n/static/f7278ec3786e0099f28691b469604df8/a120c/move_ctor.png 443w\"\n        sizes=\"(max-width: 443px) 100vw, 443px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<div class=\"align-center\">Fig: Illustration of the working of Move Constructor</div>\n<h2>The Case Against Garbage Collection</h2>\n<blockquote>\n<p>“Garbage Collection is neither general, nor ideal.”</p>\n</blockquote>\n<p>Stroustrup explained that garbage collection applies to memory only and hence does not generalize resource management. In a world that’s only getting more distributed, a garbage collector becomes a global resource that leads to only more contention.\nC++11 however, does provide a GC interface that does “Litter Collection” for legacy code that may not have handled all it’s leaks. </p>\n<h2>Object Oriented Programming</h2>\n<p>Stroustrup used “Ye good olde Shape example” to go over inheritance and polymorphism and emphasized that OOP is only fitting for a domain in which objects are truly hierarchically related.</p>\n<blockquote>\n<p>“You try to force the object into your view. You can’t. Reality is always what it will be.”</p>\n</blockquote>\n<h2>Concepts</h2>\n<p>Of the C++14 features that he introduced, the one that is closest to my heart is that of concepts. The pages of cryptic error messages generated by even a small amount of generic code can make even the staunchest of C++ programmers throw up their hands in defeat. The <em>cause</em> of these errors is the fact that the generic function does not specify the <em>interface</em> it requires on it’s inputs. Should the input iterators be random access or will bidirectional do?\nConcepts alleviate this problem by allowing you to specify requirements on your inputs.</p>\n<pre><code class=\"language-c++\">template&#x3C;typename S, typename T>\nrequires Sequence&#x3C;S>() &#x26;&#x26; Equality_comparable(Value_type&#x3C;S>, T);\nIterator_of&#x3C;S> find(S&#x26; seq, const T&#x26; val);\n</code></pre>\n<p>The template declaration requires S to be a sequence and the elements of S to be comparable with the element T, using the == operator. That’s a mouthful. It’s a good thing there’s a shorthand notation as well.\nThe error message generated by such templated functions specifies the problem quite precisely. For example:</p>\n<pre><code>error ‘list&#x3C;int>’ does not satisfy the constraint ‘Sortable’\n</code></pre>\n<p>This would be soothing to the eyes of any seasoned C++ template programmer.</p>\n<h2>A Day To Remember</h2>\n<p>It's not everyday that the creator of C++ visits your campus and it's not everyday that you get an autographed version of his latest book.\nBut today was that day.</p>","frontmatter":{"title":"Stroustrup on Campus"},"fields":{"date":"2015-01-10","slug":"2015/01/10/Stroustrup-on-Campus/"}}},"pageContext":{"slug":"2015/01/10/Stroustrup-on-Campus/","date":"2015-01-10"}},"staticQueryHashes":[]}