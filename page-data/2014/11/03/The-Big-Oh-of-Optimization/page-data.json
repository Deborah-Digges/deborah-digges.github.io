{"componentChunkName":"component---src-templates-blog-template-js","path":"/2014/11/03/The-Big-Oh-of-Optimization/","result":{"data":{"markdownRemark":{"html":"<p>We now have a functional GC, but we need to ask ourselves the question-<em>Can we do better?</em> This is a toy implementation, but if we look at something <a href=\"https://github.com/Deborah-Digges/mark-sweep-simulation/tree/master/04-Demo-GC-Pauses\">real</a>, we find that the invocation of a mark-sweep GC causes pauses in the execution of the actual program, especially for programs which show a high memory utilization. When memory hits a low, the GC is invoked, and there are <em>noticable</em> pauses. Of course, we wouldn’t want these pauses to be too long so we need to figure out <em>where</em> we can do better.</p>\n<h2>What to Optimize</h2>\n<p>A good way to identify bottlenecks is by using a profiling tool like <em>gprof</em>. We add a <em>new test</em> for performance, where we initialize a heap of a 100,000 blocks and a threshold GC invocation of 1,000 blocks. The profiling shows the following results.\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/b9fd174c520c5c8f4b32168ff9fbf197/b97f6/gprof.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 38.99999999999999%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAAAsTAAALEwEAmpwYAAABv0lEQVQoz3VR32vTUBQ+85/YX7kXQSmDIvNRH/ewCcIEFRnigzBE8EF0lcGKnc4J7axbf9w2bZM0aW6S5ia3/fY1HeqLgcO9OfnO9+NELn93cdFso9nuQI18lrcux/t7/6cGt5i+4/7B9IYuvCDCoyeHEFsYhMEUSawR6wjZPEWaJpivar6qFOtneXsu8L/n6eE7SBDEGI9DXF0pTCYhgiBBvz8m0QKzWcb3FGGYYjj0Mc+WUMrFdBpDa4MkybGkTl6sxfaev4V0u3UUVhHwi0PfYW0fjnOOkfMN7fYxer3TsqdUHZG+RBS1MBqdlVilzog5QafzE57r4vH+S4g7qcCYHcZ8QNB9ku9wYJuu7/HcgufdxWLxkEQVuq4iy6oUrzDNNqvKZFt0fARbALvPXkOmvmEsy2ZOQMJ4SzrUdKg5CIpoRl+frmuIK+D7OcVi9i1jg/M5ckPCgzcQz6vB5Od02CDomG4u6K5G8hpJPpd3a39gMPiIOP5KkTqJv9D5CUU/0eEHXF+/h45O6fAVZDIWZOYOlYT7EhIKdyLcj6DREDSbwsVvlN9mM2H0Df40KWvVa7WEpAKTbWLvxS5uAAnvOTSoSbEmAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"GPROF\"\n        title=\"GPROF\"\n        src=\"/static/b9fd174c520c5c8f4b32168ff9fbf197/5a190/gprof.png\"\n        srcset=\"/static/b9fd174c520c5c8f4b32168ff9fbf197/772e8/gprof.png 200w,\n/static/b9fd174c520c5c8f4b32168ff9fbf197/e17e5/gprof.png 400w,\n/static/b9fd174c520c5c8f4b32168ff9fbf197/5a190/gprof.png 800w,\n/static/b9fd174c520c5c8f4b32168ff9fbf197/b97f6/gprof.png 958w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<div class=\"align-center\">Fig: Gprof Profile</div>\n<p>A lot of the execution time is spent in the standard library functions and in the core GC routines - mark &#x26; sweep. We now know what to optimize.</p>\n<h2>Optimizing the Mark Routine</h2>\n<p>Revisiting the mark routine, we see that it is recursive. There is a significant time and space cost associated with such a recursive function because of the slowness of function calls and returns, and the overhead of managing the stack.\nHowever, what recursion <em>is</em> great for is <em>understanding</em> the problem. </p>\n<blockquote>\n<p>“Loops may achieve a performance gain for your program. Recursion may achieve a performance gain for your programmer”.</p>\n</blockquote>\n<p>The algorithm is succinct and lends itself to easy interpretation -\nMark an object if it isn't already marked; if it has references to other objects, mark those too.</p>\n<pre><code class=\"language-c++\">void VM::mark(Object* object)\n{\n        if(object->marked)\n        {\n                return;\n        }\n\n        object->marked = 1;\n\n        if(object->type == OBJ_PAIR)\n        {\n                mark(object->left);\n                mark(object->right);\n        }\n}\n</code></pre>\n<h2>Implementing Mark using an Explicit Stack</h2>\n<p>The mark routine can be <a href=\"https://github.com/Deborah-Digges/mark-sweep-simulation/tree/master/02-marksweep-Explicit-Stack\">implemented iteratively</a>. We use an explicit stack for traversing allocated objects. It <em>does</em> the same thing, although <a href=\"https://github.com/Deborah-Digges/mark-sweep-simulation/blob/master/02-marksweep-Explicit-Stack/vm.cpp/#L151-192\">the code</a> is more contorted and unnatural.<br/>\nAs we traverse a node, it is marked; it is pushed onto the stack if there are other nodes reachable from it--if it is not an atom. The algorithm repeateadly pops elements from the stack, marks the elements reachable from the popped element and performs the same procedure till the stack becomes empty.<br/></p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 490px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/ebd533a89eabf015079179cc02d943c7/41d3c/traversal.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 79.5%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAYAAAAWGF8bAAAACXBIWXMAAAsTAAALEwEAmpwYAAACMklEQVQ4y4VU227aQBTk5/MQ5RNQpUhR+wuhNEpQpKpESCR9aIEQbIMNxtxs4/va3ulZ38CFlpVGK53dnXOZsRuj0RArY4nFYg5dX+Qwd9BXBvTjGEHcmc+10zjFNps1er0XNJz9HidrMAB2u1qIc44wjMAYQxRFOLdUdYaGaeYP0zgGpz22bbhXV2DPz0gFUZJk52EYZhDErutme4mkuCPLEhqWaeYVCKgqzPt7QJLgtNsI396q7KIqx3EQBAH2RVeCLCsmTbNdUeQDYfbo4QHRzQ3gOojv7sBub2uEAoLE87zLhNkRzQdlAscFvczjRWuiZVGhmONlQvGoqMYJLTBefyTmJMjKWR6LdZawDAYkxcukA2UvFw/SShTfp9OE0+6TXXQYhnGhZbKKSeoa9hyrfhfRYFhVwliMrbWGtlFg2xbBrmb5T1FYp4Pg+hrYmkg+f0HUbJaNIYkTSMYIXekJqj4j3byCiP+nQvKXsEy2lssMlSgph+1YUA3lxNgpPytKmntRVJpGSMokhcLlCvywEsPytwiZT3M9J0qRJUkYuh+P0HaTmsp50Uv6GuQsUxj7+Gn0MDZ+YzKWYJPZZ7Np3TYJT7KWtJ0M2XjH3rMrMk3T0Gq10KYv6LXfR0xzMzdT+MHhznSq1EWZbj7wffyNiBl+zft4nf04JCMfCvikbCy8Z1lA8xP4UwcS/X0Umv14/F4n9JmHtaNn8xTzEfi77SMfgbe/gg+HCKlaThA/hz+8GMrli2dmXAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"GPROF\"\n        title=\"GPROF\"\n        src=\"/static/ebd533a89eabf015079179cc02d943c7/41d3c/traversal.png\"\n        srcset=\"/static/ebd533a89eabf015079179cc02d943c7/772e8/traversal.png 200w,\n/static/ebd533a89eabf015079179cc02d943c7/e17e5/traversal.png 400w,\n/static/ebd533a89eabf015079179cc02d943c7/41d3c/traversal.png 490w\"\n        sizes=\"(max-width: 490px) 100vw, 490px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<div class=\"align-center\">Fig: Mark Using an Explicit Stack</div>\n<p>So, we've managed to convert the recursive algorithm into an iterative one, with some loss of elegance in the program code and some gain in speed.</p>\n<h2>Premature Optimization is the Root of All Evil</h2>\n<p>It’s a good idea to get a good grasp of the problem you’re trying to solve before trying to solve it better. Recursion helped us with just this--we <em>understood</em> what we were trying to do and <em>then</em> tried improving it.</p>\n<p>While this code does improve our algorithm’s time, there is still the question of space. The size of the stack used for traversal grows linearly with the number of objects being traversed.</p>\n<p>We ask ourselves the golden question-<em>can we do better?</em></p>","frontmatter":{"title":"The Big Oh of Optimization"},"fields":{"date":"2014-11-03","slug":"2014/11/03/The-Big-Oh-of-Optimization/"}}},"pageContext":{"slug":"2014/11/03/The-Big-Oh-of-Optimization/","date":"2014-11-03"}},"staticQueryHashes":[]}