{"componentChunkName":"component---src-templates-blog-template-js","path":"/2014/10/23/Simulating-a-Mark-Sweep-GC/","result":{"data":{"markdownRemark":{"html":"<p>To understand the basic machinery of a garbage collector, consider a <em>virtual machine</em> that has to its disposal a pool of <em>free memory</em>--typically called the <em>heap</em>. Requests for memory needed at run time are satisfied from this free list. <br/>\nA simplifying assumption we are making is that allocation of memory is always in <em>fixed size</em> blocks. If this weren’t the case, we would have to slay an ugly dragon called <em>fragmentation</em> which we will save for another day.<br/>\nThe virtual machine’s <em>execution stack</em> holds references to objects, which can either be atomic or can in turn hold references to other objects. </p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/51c09c35d094ec56ab14d77bc35fbf48/416ee/gc.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 56.49999999999999%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsTAAALEwEAmpwYAAABo0lEQVQoz3VTDY+iUAzk//+0Te6yRjfypbgCIgJPPgURptc+gXP39po0bTJl3nRSjOv1irZtqWka1HUtlW63G73235O/od1uR1mW6RmZlRTMEDIOcOjBNE3JsixSStFPMY4jeAa+7yOOY92fz2eUZQnBDWbFzNiWJT36Hl3X0TAMmILmKmOPx0M/erlcdCZJQkEQ6Cq4IZL5VRo4eZq40cCsaGGaKhMiDEOtShQyqe6rqnoqZKkURRF9Hg4UXxIqziHyUlFaJFBltpC9EvI8TqeTrkImD+R5vqysFQpYFhW5hy021i9af7zB3a//IRQP2XeIVZJz37NVmlBWlui6loqigvdp0d5Z0T504Ee7v4Qva/8vBF8I5WxE4eHowDtu0ZwiqtnsmWdZ+X6HchxEQQDP86h4rrpsIISYCfO8INNeYev+5o9cUqaJ74R91yHarJFdYj6dgJq6nrfQqT2czgH9vacgPsLzTaj3FZTrftlIW9N3+PA3MO0tbNumEeMXGwy+cOizme5uPqE6jqniexuemMYFE/NVkaK5NfoPEyETrvMPGwRP0ESKVAAAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"VM\"\n        title=\"VM\"\n        src=\"/static/51c09c35d094ec56ab14d77bc35fbf48/5a190/gc.png\"\n        srcset=\"/static/51c09c35d094ec56ab14d77bc35fbf48/772e8/gc.png 200w,\n/static/51c09c35d094ec56ab14d77bc35fbf48/e17e5/gc.png 400w,\n/static/51c09c35d094ec56ab14d77bc35fbf48/5a190/gc.png 800w,\n/static/51c09c35d094ec56ab14d77bc35fbf48/416ee/gc.png 930w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<div class=\"align-center\">Fig: Illustration of the working of a GC</div>\n<h2>What does Allocation Involve?</h2>\n<p>Allocation of memory for any purpose, such as object creation, involves removing a memory block from the <em>free list</em> and adding it to the <em>allocated list</em>. The reference to the newly created object will be pushed onto the stack, so the program can manipulate its contents.</p>\n<h2>What are Reachable Objects?</h2>\n<p>Reachable objects are those referenced directly from the stack or those that can be reached by following references from reachable objects. This is a naturally recursive definition, which results in a graph of reachable objects, starting from the roots of the program--the variables referenced from the execution stack. Only reachable objects are those truly usable by the program(You can’t use an object if you can’t get to it).\nThe objects shown in <em>green</em> are those reachable.</p>\n<h2>Garbage == Unreachable Objects?</h2>\n<p>Any object that is unreachable is termed garbage because it is not of any use to the executing program. It can’t be allocated for any other request despite it being unused.<br/>\nThe objects shown in <em>red</em> are the ones unreachable, ripe for collection.</p>\n<h2>The Mark Phase</h2>\n<p>Starting from the objects referenced from the stack, all reachable objects are <em>marked</em>. At the end of this phase, the objects shown in green will be marked.</p>\n<h2>The Sweep Phase</h2>\n<p>The objects which are unreachable are <em>collected</em> which moves them to the free list. A single pass is made through the allocated list, and all objects unmarked at the end of the mark phase are removed from this list and returned to the free list.</p>\n<h2>When Can the GC be invoked?</h2>\n<ol>\n<li>Explicitly -- akin to Java’s System.gc() call( Although this is only a <i>suggestion</i> to the JVM)</li>\n<li>When memory runs low or even dry.</li>\n<li>When the number of allocations crosses some predefined threshold.</li>\n</ol>\n<p>So, there it is - A <em>simulation</em> of a mark sweep GC.<br/>\nYou can find the code for the above simulation <a href=\"https://github.com/Deborah-Digges/mark-sweep-simulation/tree/master/01-marksweep-simple\">here</a>.</p>","frontmatter":{"title":"Simulating a Mark Sweep GC"},"fields":{"date":"2014-10-23","slug":"2014/10/23/Simulating-a-Mark-Sweep-GC/"}}},"pageContext":{"slug":"2014/10/23/Simulating-a-Mark-Sweep-GC/","date":"2014-10-23"}},"staticQueryHashes":[]}